# AutoencoderDC (DCAE) wrapped for EulerAudioBackbone

model:
  autoencoder:
    return_latent: false
    pre_transform:
      type: power_norm     # none | log_mag | power_norm
      apply_target: true
      apply_inverse: true
      config:
        eps: 1.0e-8
        alpha: 0.65
        beta: 0.35

  encoder:
    _target_: ar_spectra.models.autoencoder_dc.HFAutoencoderDCEncoder
    # input_size MUST match data.model_channels (complex-as-channels stereo => 4)
    input_size: 4
    is_complex: true
    latent_channels: 32
    attention_head_dim: 32
    encoder_block_types: ResBlock
    encoder_block_out_channels: [128, 256, 512, 512, 1024, 1024]
    encoder_layers_per_block: [2, 2, 2, 3, 3, 3]
    encoder_qkv_multiscales:
      - []
      - []
      - []
      - [5]
      - [5]
      - [5]
    downsample_block_type: pixel_unshuffle
    encoder_out_shortcut: true
    scaling_factor: 1.0

  decoder:
    _target_: ar_spectra.models.autoencoder_dc.HFAutoencoderDCDecoder
    # channels MUST match data.model_channels (complex-as-channels stereo => 4)
    channels: 4
    is_complex: true
    latent_channels: 32
    attention_head_dim: 32
    decoder_block_types: ResBlock
    decoder_block_out_channels: [128, 256, 512, 512, 1024, 1024]
    decoder_layers_per_block: [3, 3, 3, 3, 3, 3]
    decoder_qkv_multiscales:
      - []
      - []
      - []
      - [5]
      - [5]
      - [5]
    upsample_block_type: pixel_shuffle
    decoder_norm_types: rms_norm
    decoder_act_fns: silu
    decoder_in_shortcut: true
    decoder_conv_act_fn: relu
    scaling_factor: 1.0

  bottleneck:
    _target_: ar_spectra.models.bottlenecks.VAEBottleneck
